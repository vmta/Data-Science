
﻿1
00:00:13,250 --> 00:00:15,634
В консольном режиме,
в котором мы работали только что,
команда исполняется немедленно.
Ввел команду, нажал Enter,
она исполнилась.
Ввел следующую команду,
нажал Enter, она исполнилась.
В реальной работе, конечно, реальный
анализ данных связан с выполнением
большого количества команд, и поэтому
имеет смысл набрать их все в одном файле,
а потом все одним разом запустить.
И этот второй режим работы
– это написание скрипта.
Перейдем к написанию
нашего первого скрипта.
Выбираем, нажимаем плюсик
и тут выбираем R Script,
соответственно вот у нас появится
дополнительное окошко, и в этом окошке,
когда мы нажимаем Enter,
то ничего не происходит.
Команда сразу выполняться не будет.
Давайте создадим здесь несколько векторов.
Например, создадим вектор х из чисел 23,
15, 46, NA.
Вектор z из чисел 5,
6, NA, 8.
И давайте попробуем исполнить
эти введенные команды,
то есть здесь команда не
выполняется сразу после написания.
Чтобы исполнить команду достаточно встать
в любое место строки, можно в конец,
можно в начало, не обязательно.
Где находится курсор, там и отлично.
И нажать в зависимости
от операционной системы,
под Windows это будет Ctrl+Enter,
а на Маке это будет Command+Enter.
Соответственно, исполнилась
первая команда,
х = вектору 23, 15,
46, пропущенное значение,
и исполняем вторую команду z = 5,
6, пропущенное значение, 8.
Что я могу сделать с векторами?
У векторов я могу попробовать посчитать,
например, среднее значение.
Если я наберу mean(x) и нажму Ctrl+Enter,
то компьютер попытается посчитать
собственное значение, среднее значение.
Но поскольку есть пропущенное наблюдение,
то узнать среднее значение вот
этих четырех чисел невозможно.
Ну, в R есть удобная работа
с пропущенными наблюдениями,
в данном случаем мне достаточно
просто указать, что опцию,
опцию «опустить пропущенные значения»,
то есть я набираю среднее значение
х и указываю дополнительные опции,
что пропущенные значения
na надо rm опустить.
И получается, что среднее значение,
если не считать пропущенные
неизвестные значения, равно 28.
Еще раз не забывайте, что работает Tab,
то есть я на самом деле не набирал na.rm.
Я набрал, например, mean(z,),
а дальше нажал Tab и посмотрел, какие
опции есть у функции, их можно прочитать.
Соответственно, вот выбрал опцию na.rm,
нажал Enter,
установил, что ее надо использовать,-
TRUE (истинное значение),
и получил среднее значение переменной
z при игнорировании пропущенных значений.
Помимо, естественно, среднего,
можно посчитать над векторами
кучу других операций.
Например, можно посчитать сумму.
Опять же если не игнорировать
пропущенные значения, сумма не известна,
однако можно проигнорировать
пропущенные значения
и получить сумму всех чисел,
кроме пропущенных.
Следующий объект,
который очень часто встречается в R
помимо вектора – это табличка с данными.
Табличка с данными – это двумерный объект,
то есть есть несколько столбцов
одинаковой длины и много-много строк,
как правило.
Давайте объединим наши
вектора x и z в табличку d.
Ну пусть, к примеру,
х – это будет рост некоторых инопланетян,
а z – это будет вес некоторых
четырех инопланетян.
Создадим табличку d data.frame.
Давайте напишем,
что рост мы берем из переменной х,
а вес берем из переменной z.
Нажимаем Ctrl+Enter,
и компьютер объединил два
вектора х и z в табличку d.
Давайте посмотрим,
как устроена табличка d.
Напишем d, нажмем Ctrl+Enter.
И вот мы видим,
что d – это двумерная табличка,
здесь есть переменная
рост и переменная вес.
И наблюдение.
Первое наблюдение-
рост 23, вес 5.
Второе наблюдение-
рост 15, вес 6 и так далее.
Как адресовать двумерный объект?
Соответственно, можно адресовать
любой конкретный элемент.
Например, если я хочу раздобыть
элемент из 4-й строки 1-го столбца,
то мне надо написать d [4, 1].
Это будет 4-я строка, 1-й столбец.
И я нажимаю Ctrl+Enter,
и действительно это пропущенное значение.
Например, могу раздобыть элемент из
3-й строки 1-го столбца: d [3, 1]-
это 46.
Могу раздобыть какую-нибудь
строчку целиком,
для этого тогда надо просто пропустить
номер столбца, не указывать его: d [2,
] и, не указав номер столбца,
я получаю всю соответствующую строчку.
Аналогично, не указав номер строки,
можно получить весь столбец целиком d [,
2] – это будет второй столбец.
Также можно адресовать столбцы по именам.
Например, если я напишу d$rost,
опять же не забывайте, что работает Tab.
Я начал писать d$ro и нажимаю Tab,
хоп, и само появляется st.
Это, соответственно,
будет столбец rost из таблички d,
и могу точно так же после $ нажать Tab
и посмотреть, какие есть варианты.
d$ves из таблички d.
Помимо табличек с данными, в R также
очень популярен такой объект, как списки.
Список удобно себе представлять
как чулан со всяким хламом.
Если табличка обладает
стандартными размерами,
ну обязательно в каждой табличке
есть какое-то число строк,
какое-то число столбцов, и в каждом
столбце одинаковое количество строк,
то в список могут входить
объекты совершенно разнородные.
Ну давайте попробуем создать, например,
список, который называется my_list,
в который войдут число а = 7,
вектор b чисел от 10 до 20 и табличка,
табличка, под названием table,
и мы под названием table в список my_list
поместим нашу уже созданную табличку d.
Нажимаем Ctrl+Enter,
у нас создался объект my_list.
my_list – это набор из трех
совершенно разнородных объектов.
my_list$a – это число 7,
my_list$b – это вектор,
my_list$table, нажимаем
Ctrl+Enter – это целая табличка.
Очень часто результаты оценивания всяких
моделей представлены в виде списка,
потому что, как правило, когда мы будем
оценивать с помощью метода наименьших
квадратов модель, то результатом
оценивания являются и вектор оценок β с
крышкой, и число R-квадрат,
то поэтому результаты
оценивания многих функций в
R являются именно списком.
Список адресуется немножко по-другому,
чем таблица.
Ну, во-первых,
работает один из старых способов адресации
по имени входящего объекта,
то есть когда у нас в табличку входило,
столбец рост, то мы могли написать
d$rost (d$rost) и получить вектор,
состоящий из 4-х чисел.
Такой же способ адресации работы в списке,
ну можно еще адресовать по номерам.
Например, если я напишу my_list,
и в двойных квадратных скобках
можно указать номер объекта,
ну например, у меня тут 3 объекта: число,
вектор и табличка.
Соответственно, если я в квадратных
скобках напишу my_list2,
то это будет второй объект в списке.
Второй объект в списке это будет вектор b.
Можно по именам, а можно по номерам.
Когда вы написали длинный-длинный скрипт
с кучей нужных вам команд,
вы можете радостно написать,
«ура!» и сохранить ваш скрипт
для дальнейшего использования.
Выбираем File, Save.
Когда вы работаете с русским языком,
один из первых нюансов,
с которым вам придется столкнуться
– это разные кодировки.
Русские буквы можно закодировать
в файле разными способами.
Два самых распространенных способа
– это (самых популярных в России),
это, соответственно, CP1251,
который распространен под Windows,
и UTF-8, который используется
под Маком и на Линуксе.
Соответственно, удобней оказывается UTF-8,
потому что эта кодировка позволяет в одном
файле использовать не только русский язык,
но, скажем, там немецкие умляуты,
французские акценты и так далее.
Поэтому мы будем сохранять
в кодировке UTF-8 и,
соответственно, здесь мы поставим галочку,
что эта кодировка UTF-8 будет являться
кодировкой по умолчанию для всех файлов.
Однако, если вы столкнетесь с каким-то
явлением, увидите,
что у вас не русские буквы,
а какие-то кракозябры, ну вот,
например, если я открою файл в
неправильной кодировке,
сейчас мой файл записан в кодировке UTF-8.
Однако если я выберу
неправильную кодировку,
укажу компьютеру, что это кодировка
CP1251, то «ура» превратится в кракозябры.
Поэтому если вы видите вместо комментариев
кракозябры, то вы выбираете File,
Reopen with Encoding и выбираете,
скорей всего, одну из двух кодировок-
либо CP1251, либо UTF-8.

