
﻿1
00:00:12,740 --> 00:00:16,734
Сейчас мы научимся
писать простые и полезные функции в R.
Каждая функция в R была
когда-то кем-то написана.
Мы сейчас с вами научимся
писать свои функции.
Для начала напишем совсем простую функцию,
которая возводит числа в квадрат.
Она абсолютно бесполезна, зато своя.
Мы называем функцию f,
f — это будет функция.
Аргументом функции является число x.
Дальше в фигурных скобках находится код,
который вычисляет функцию.
Ну действительно, чтобы получить
результат, мы должны x возвести в квадрат.
А дальше мы должны вернуть результат.
Вот такой простой код: третья строчка
вычисляет значение переменной,
res, а четвёртая строчка говорит,
что res и является результатом функции.
Выделяем код функции,
нажимаем Ctrl + Enter.
После этого мы можем нашу
функцию использовать.
Например, f(3),
нажимаем Ctrl + Enter, получаем 9.
f от минус единички, нажимаем, получаем 1.
То есть наша функция прекрасно работает,
теперь она известна R.
Напишем чуть более сложную функцию,
функцию,
которая использует
необязательные параметры.
Как правило, есть некое
стандартное использование функции,
а есть более продвинутое
использование функции.
То есть добавим в нашу функцию опцию,
что можно было бы указывать степень,
в которую надо возвести x.
Перепишем код нашей функции и добавим
необязательный параметр,
который назовём степень (stepen).
И по умолчанию stepen будет равна 2,
но можно будет указать любую другую.
Соответственно, результат...
Давайте и функцию назовём по-другому,
функцию назовём fs.
Соответственно, результат — это x,
возведённый в степень.
И функция возвращает результат.
Выделяем код функции,
нажимаем Ctrl + Enter.
Теперь компьютер знаком с функцией fs.
Можем проверить её функциональность.
Если не указывать степень, то по-прежнему
можно писать fs от одного аргумента.
fs(4) — это 16.
Однако теперь появилась опция
возводить в любую степень.
Например, я могу написать fs(2) и сказать,
что степень равна 5.
И получается два в пятой — 32.
По-прежнему работает tab.
Поэтому если я наберу fs и нажму tab,
то компьютер мне покажет,
что у моей функции есть два аргумента:
x и stepen, что помогает запомнить.
Давайте теперь напишем чуть
более полезную функцию, которая,
например, считает процент отсутствующих
наблюдений в табличке с данными.
Очень часто в реальности
либо при заполнении
опросов пользователя,
не отвечает на все вопросы целиком,
либо по каким-либо другим причинам
в данных имеются пропуски.
И очень важно, когда вы работаете
с данными, представлять себе,
а насколько велик процент
пропущенных наблюдений.
Поэтому мы с вами напишем простую функцию,
которая, тем не менее, уже полезна:
она считает процент пропущенных
наблюдений в табличке с данными.
Для примера мы сначала
посчитаем это без функции.
Рассмотрим встроенный массив данных cars,
это набор данных по машинам.
Поместим его для краткости в переменную d,
в табличку d, d = cars.
Тут нет пропущенных данных,
но мы их добавим.
Например, d с координатами первая строчка,
второй столбец будет
пропущенным наблюдением,
и d с координатами третья строчка,
первый столбец тоже будет
пропущенным наблюдением.
Посмотрим на наш массивчик d, и мы видим,
что в начале массива d есть пропуски.
Есть функция,
которая определяет, является ли каждое
наблюдение пропущенным значением.
Эта функция называется is.na
от таблички с данными.
То есть эта функция будет
равна TRUE в том месте,
где наблюдение пропущено, и FALSE в том
месте, где наблюдение присутствует.
Соответственно, внутри памяти компьютер
работает со словами FALSE и TRUE
как с ноликами и единичками.
Соответственно, их можно
просто просуммировать.
Если я просуммирую FALSE + FALSE,
это будет 0 + 0, это будет ноль, а если
я просуммирую TRUE (истина) + FALSE,
это будет 1 + 0, это будет единичка.
Соответственно, просто банально
просуммировав всю табличку,
где указаны TRUE для
отсутствующих наблюдений,
я получу количество
отсутствующих наблюдений.
После этого, чтобы посчитать
процент отсутствующих наблюдений,
мне останется только поделить эту сумму на
количество строк и количество столбцов.
Соответственно, мой результат
— это будет сумма таблички
из TRUE для отсутствующих наблюдений
делить на количество строк в d,
делить на количество столбцов в d,
поскольку количество
строк помножить на количество столбцов
даст количество элементов в d.
Проверяю, что всё работает.
Результат: вот в моём наборе данных
2 % отсутствующих наблюдений.
И теперь осталось оформить
это в виде функции.
Пишем, что наша функция,
ну давайте назовём её na_percentage,
na_perc = function от
таблички с данными d.
Фигурная скобка открывается,
здесь фигурная скобка закроется.
Уберём наши промежуточные
попытки придумывания,
изобретения этой функции,
и останется только сказать,
что функция должна возвращать результат
и отступить для
читаемости кода
два пробела слева от команд.
Знакомим компьютер с нашей функцией,
выделив её и запустив.
Теперь мы можем считать процент
отсутствующих наблюдений в табличке d.
И он, естественно, равен 0,02.
Когда вы пишете большой сложный проект,
в котором много функций, то неплохо бы,
чтобы функция проверяла
корректность ввода аргументов.
Не то чтобы функция работает в окружении
врагов и должна всем не доверять
и всё-всё-всё перепроверять,
но какую-то банальную проверку,
что всё, что введено в функцию,
введено верно, имеет смысл поставить.
Давайте расширим нашу функцию, которая
считает процент отсутствующих наблюдений,
просто проверкой, а правильно ли, что то,
что ей подсунули в качестве аргумента d,
это табличка с данными.
Соответственно, мы добавим,
в начале функцию,
команду, которая будет проверять,
что аргумент d является
табличкой с данными.
То есть если — восклицательный
знак означает «не»
— если аргумент d не является
табличкой с данными,
если не табличка с данными d,
то тогда функция
должна выдать сообщение об ошибке
и прервать своё исполнение.
Если d не является табличкой с данными,
то функция не будет исполнена,
а будет выведено сообщение об ошибке,
d should be a data.frame.
Соответственно, запускаем нашу функцию.
И давайте ей подсунем табличку с данными,
проверим, что она нормально
обрабатывает таблички с данными.
И подсунем ей какой-нибудь вектор.
Пусть x — это будет вектор из чисел 5,
6, 7.
Но поскольку в нашей функции есть деление
на количество строк, деление на количество
столбцов, то поэтому с векторами,
конечно, наша функция работать не будет.
И если мы применим нашу
функцию к вектору x,
то наша функция выдаст
осмысленное сообщение об ошибке,
что переменная d должна
быть табличкой с данными.
И это позволит избежать
более серьёзных ошибок.
Сообщение об ошибке — это правильно.

