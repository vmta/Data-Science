1
00:00:12,740 --> 00:00:16,734
Сейчас мы научимся

2
00:00:16,734 --> 00:00:21,636
писать простые и полезные функции в R.

3
00:00:21,636 --> 00:00:24,966
Каждая функция в R была
когда-то кем-то написана.

4
00:00:24,966 --> 00:00:27,550
Мы сейчас с вами научимся
писать свои функции.

5
00:00:27,550 --> 00:00:31,630
Для начала напишем совсем простую функцию,
которая возводит числа в квадрат.

6
00:00:31,630 --> 00:00:35,934
Она абсолютно бесполезна, зато своя.

7
00:00:35,934 --> 00:00:40,418
Мы называем функцию f,
f — это будет функция.

8
00:00:40,418 --> 00:00:43,640
Аргументом функции является число x.

9
00:00:43,640 --> 00:00:48,030
Дальше в фигурных скобках находится код,
который вычисляет функцию.

10
00:00:48,030 --> 00:00:53,300
Ну действительно, чтобы получить
результат, мы должны x возвести в квадрат.

11
00:00:53,300 --> 00:00:56,900
А дальше мы должны вернуть результат.

12
00:00:56,900 --> 00:01:02,715
Вот такой простой код: третья строчка
вычисляет значение переменной,

13
00:01:02,715 --> 00:01:06,960
res, а четвёртая строчка говорит,
что res и является результатом функции.

14
00:01:06,960 --> 00:01:09,791
Выделяем код функции,
нажимаем Ctrl + Enter.

15
00:01:09,791 --> 00:01:12,690
После этого мы можем нашу
функцию использовать.

16
00:01:12,690 --> 00:01:17,940
Например, f(3),
нажимаем Ctrl + Enter, получаем 9.

17
00:01:17,940 --> 00:01:21,071
f от минус единички, нажимаем, получаем 1.

18
00:01:21,071 --> 00:01:25,470
То есть наша функция прекрасно работает,
теперь она известна R.

19
00:01:25,470 --> 00:01:28,586
Напишем чуть более сложную функцию,
функцию,

20
00:01:28,586 --> 00:01:31,780
которая использует
необязательные параметры.

21
00:01:31,780 --> 00:01:36,575
Как правило, есть некое
стандартное использование функции,

22
00:01:36,575 --> 00:01:39,320
а есть более продвинутое
использование функции.

23
00:01:39,320 --> 00:01:43,379
То есть добавим в нашу функцию опцию,
что можно было бы указывать степень,

24
00:01:43,379 --> 00:01:44,830
в которую надо возвести x.

25
00:01:44,830 --> 00:01:49,544
Перепишем код нашей функции и добавим

26
00:01:49,544 --> 00:01:53,290
необязательный параметр,
который назовём степень (stepen).

27
00:01:53,290 --> 00:01:59,829
И по умолчанию stepen будет равна 2,
но можно будет указать любую другую.

28
00:01:59,829 --> 00:02:02,580
Соответственно, результат...

29
00:02:02,580 --> 00:02:07,320
Давайте и функцию назовём по-другому,
функцию назовём fs.

30
00:02:07,320 --> 00:02:11,770
Соответственно, результат — это x,
возведённый в степень.

31
00:02:11,770 --> 00:02:14,837
И функция возвращает результат.

32
00:02:14,837 --> 00:02:19,180
Выделяем код функции,
нажимаем Ctrl + Enter.

33
00:02:19,180 --> 00:02:21,655
Теперь компьютер знаком с функцией fs.

34
00:02:21,655 --> 00:02:24,131
Можем проверить её функциональность.

35
00:02:24,131 --> 00:02:31,020
Если не указывать степень, то по-прежнему
можно писать fs от одного аргумента.

36
00:02:31,020 --> 00:02:33,927
fs(4) — это 16.

37
00:02:33,927 --> 00:02:38,717
Однако теперь появилась опция
возводить в любую степень.

38
00:02:38,717 --> 00:02:44,630
Например, я могу написать fs(2) и сказать,
что степень равна 5.

39
00:02:44,630 --> 00:02:49,220
И получается два в пятой — 32.

40
00:02:49,220 --> 00:02:52,039
По-прежнему работает tab.

41
00:02:52,039 --> 00:02:57,367
Поэтому если я наберу fs и нажму tab,
то компьютер мне покажет,

42
00:02:57,367 --> 00:03:02,600
что у моей функции есть два аргумента:
x и stepen, что помогает запомнить.

43
00:03:02,600 --> 00:03:07,061
Давайте теперь напишем чуть
более полезную функцию, которая,

44
00:03:07,061 --> 00:03:11,990
например, считает процент отсутствующих
наблюдений в табличке с данными.

45
00:03:11,990 --> 00:03:16,736
Очень часто в реальности
либо при заполнении

46
00:03:16,736 --> 00:03:21,209
опросов пользователя,
не отвечает на все вопросы целиком,

47
00:03:21,209 --> 00:03:24,820
либо по каким-либо другим причинам
в данных имеются пропуски.

48
00:03:24,820 --> 00:03:28,333
И очень важно, когда вы работаете
с данными, представлять себе,

49
00:03:28,333 --> 00:03:31,120
а насколько велик процент
пропущенных наблюдений.

50
00:03:31,120 --> 00:03:36,760
Поэтому мы с вами напишем простую функцию,
которая, тем не менее, уже полезна:

51
00:03:36,760 --> 00:03:41,830
она считает процент пропущенных
наблюдений в табличке с данными.

52
00:03:41,830 --> 00:03:46,190
Для примера мы сначала
посчитаем это без функции.

53
00:03:46,190 --> 00:03:52,800
Рассмотрим встроенный массив данных cars,
это набор данных по машинам.

54
00:03:52,800 --> 00:03:59,789
Поместим его для краткости в переменную d,
в табличку d, d = cars.

55
00:03:59,789 --> 00:04:04,120
Тут нет пропущенных данных,
но мы их добавим.

56
00:04:04,120 --> 00:04:08,482
Например, d с координатами первая строчка,

57
00:04:08,482 --> 00:04:11,850
второй столбец будет
пропущенным наблюдением,

58
00:04:11,850 --> 00:04:15,970
и d с координатами третья строчка,

59
00:04:15,970 --> 00:04:20,791
первый столбец тоже будет
пропущенным наблюдением.

60
00:04:20,791 --> 00:04:27,920
Посмотрим на наш массивчик d, и мы видим,
что в начале массива d есть пропуски.

61
00:04:27,920 --> 00:04:32,155
Есть функция,

62
00:04:32,155 --> 00:04:36,390
которая определяет, является ли каждое
наблюдение пропущенным значением.

63
00:04:36,390 --> 00:04:41,825
Эта функция называется is.na
от таблички с данными.

64
00:04:41,825 --> 00:04:46,533
То есть эта функция будет
равна TRUE в том месте,

65
00:04:46,533 --> 00:04:52,260
где наблюдение пропущено, и FALSE в том
месте, где наблюдение присутствует.

66
00:04:52,260 --> 00:04:57,644
Соответственно, внутри памяти компьютер

67
00:04:57,644 --> 00:05:01,856
работает со словами FALSE и TRUE
как с ноликами и единичками.

68
00:05:01,856 --> 00:05:04,972
Соответственно, их можно
просто просуммировать.

69
00:05:04,972 --> 00:05:10,080
Если я просуммирую FALSE + FALSE,
это будет 0 + 0, это будет ноль, а если

70
00:05:10,080 --> 00:05:15,850
я просуммирую TRUE (истина) + FALSE,
это будет 1 + 0, это будет единичка.

71
00:05:15,850 --> 00:05:20,919
Соответственно, просто банально
просуммировав всю табличку,

72
00:05:20,919 --> 00:05:25,380
где указаны TRUE для
отсутствующих наблюдений,

73
00:05:25,380 --> 00:05:28,830
я получу количество
отсутствующих наблюдений.

74
00:05:28,830 --> 00:05:33,113
После этого, чтобы посчитать
процент отсутствующих наблюдений,

75
00:05:33,113 --> 00:05:39,120
мне останется только поделить эту сумму на
количество строк и количество столбцов.

76
00:05:39,120 --> 00:05:46,004
Соответственно, мой результат
— это будет сумма таблички

77
00:05:46,004 --> 00:05:52,754
из TRUE для отсутствующих наблюдений
делить на количество строк в d,

78
00:05:52,754 --> 00:05:57,492
делить на количество столбцов в d,
поскольку количество

79
00:05:57,492 --> 00:06:01,080
строк помножить на количество столбцов
даст количество элементов в d.

80
00:06:01,080 --> 00:06:05,210
Проверяю, что всё работает.

81
00:06:05,210 --> 00:06:09,340
Результат: вот в моём наборе данных
2 % отсутствующих наблюдений.

82
00:06:09,340 --> 00:06:12,790
И теперь осталось оформить
это в виде функции.

83
00:06:12,790 --> 00:06:19,290
Пишем, что наша функция,
ну давайте назовём её na_percentage,

84
00:06:19,290 --> 00:06:25,580
na_perc = function от
таблички с данными d.

85
00:06:25,580 --> 00:06:31,790
Фигурная скобка открывается,
здесь фигурная скобка закроется.

86
00:06:31,790 --> 00:06:35,867
Уберём наши промежуточные
попытки придумывания,

87
00:06:35,867 --> 00:06:41,040
изобретения этой функции,
и останется только сказать,

88
00:06:41,040 --> 00:06:47,102
что функция должна возвращать результат

89
00:06:47,102 --> 00:06:51,671
и отступить для

90
00:06:51,671 --> 00:06:56,390
читаемости кода

91
00:06:56,390 --> 00:07:01,020
два пробела слева от команд.

92
00:07:01,020 --> 00:07:05,880
Знакомим компьютер с нашей функцией,
выделив её и запустив.

93
00:07:05,880 --> 00:07:11,950
Теперь мы можем считать процент
отсутствующих наблюдений в табличке d.

94
00:07:11,950 --> 00:07:14,558
И он, естественно, равен 0,02.

95
00:07:14,558 --> 00:07:20,219
Когда вы пишете большой сложный проект,
в котором много функций, то неплохо бы,

96
00:07:20,219 --> 00:07:25,310
чтобы функция проверяла
корректность ввода аргументов.

97
00:07:25,310 --> 00:07:30,316
Не то чтобы функция работает в окружении
врагов и должна всем не доверять

98
00:07:30,316 --> 00:07:34,986
и всё-всё-всё перепроверять,
но какую-то банальную проверку,

99
00:07:34,986 --> 00:07:39,917
что всё, что введено в функцию,
введено верно, имеет смысл поставить.

100
00:07:39,917 --> 00:07:44,792
Давайте расширим нашу функцию, которая
считает процент отсутствующих наблюдений,

101
00:07:44,792 --> 00:07:49,030
просто проверкой, а правильно ли, что то,
что ей подсунули в качестве аргумента d,

102
00:07:49,030 --> 00:07:50,992
это табличка с данными.

103
00:07:50,992 --> 00:07:55,796
Соответственно, мы добавим,
в начале функцию,

104
00:07:55,796 --> 00:08:00,062
команду, которая будет проверять,

105
00:08:00,062 --> 00:08:05,116
что аргумент d является
табличкой с данными.

106
00:08:05,116 --> 00:08:10,502
То есть если — восклицательный
знак означает «не»

107
00:08:10,502 --> 00:08:15,594
— если аргумент d не является
табличкой с данными,

108
00:08:15,594 --> 00:08:20,763
если не табличка с данными d,
то тогда функция

109
00:08:20,763 --> 00:08:25,790
должна выдать сообщение об ошибке
и прервать своё исполнение.

110
00:08:25,790 --> 00:08:29,337
Если d не является табличкой с данными,

111
00:08:29,337 --> 00:08:34,580
то функция не будет исполнена,
а будет выведено сообщение об ошибке,

112
00:08:34,580 --> 00:08:41,360
d should be a data.frame.

113
00:08:41,360 --> 00:08:46,646
Соответственно, запускаем нашу функцию.

114
00:08:46,646 --> 00:08:50,352
И давайте ей подсунем табличку с данными,

115
00:08:50,352 --> 00:08:54,460
проверим, что она нормально
обрабатывает таблички с данными.

116
00:08:54,460 --> 00:08:56,846
И подсунем ей какой-нибудь вектор.

117
00:08:56,846 --> 00:08:59,910
Пусть x — это будет вектор из чисел 5,
6, 7.

118
00:08:59,910 --> 00:09:05,150
Но поскольку в нашей функции есть деление
на количество строк, деление на количество

119
00:09:05,150 --> 00:09:09,700
столбцов, то поэтому с векторами,
конечно, наша функция работать не будет.

120
00:09:09,700 --> 00:09:13,210
И если мы применим нашу
функцию к вектору x,

121
00:09:13,210 --> 00:09:17,767
то наша функция выдаст
осмысленное сообщение об ошибке,

122
00:09:17,767 --> 00:09:22,171
что переменная d должна
быть табличкой с данными.

123
00:09:22,171 --> 00:09:26,102
И это позволит избежать
более серьёзных ошибок.

124
00:09:26,102 --> 00:09:28,570
Сообщение об ошибке — это правильно.

