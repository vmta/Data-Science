Рассмотрим встроенный набор данных,
многомерный временной ряд
под названием Investment,
data("Investment").
Давайте посмотрим описание этого ряда,
help("Investment").
Соответственно, это набор данных с
1963-го по 1982-й год, семь переменных.
Это данные по Америке.
Соответственно, GNP,
валовый национальный продукт,
инвестиции, индекс цен,
процентная ставка и,
соответственно, реальный валовый
национальный продукт и так далее.
Соответственно, как можно работать с этим
объектом, самые простейшие операции?
Во-первых, можно посмотреть, когда
начинаются данные, start(Invesnment).
1963-й.
Можно посмотреть end(Investment),
когда заканчивается наш временной ряд.
Соответственно, 82-й год.
Можно посмотреть, собственно, индекс,
переменную, которая отвечает за время,
time(Investment).
И видно,
что это вот годовые временные ряды,
частота — одно наблюдение на один год:
начало, конец и, собственно, сами индексы.
И есть такое понятие как coredata,
то есть это основная часть массива,
то есть без переменной,
которая отвечает за время,
а просто сами значения показателей,
coredata(Investment).
И здесь у нас есть GNP, Investment,
Price и так далее.
Соответственно, какие ещё простые
операции позволяет делать пакет zoo?
Например, можно восстановить
некоторые пропущенные значения одним
из двух простейших алгоритмов.
Давайте искусственно введём
пропущенные значения.
Скажем, GNP.
Поставим туда пропуск на
какое-нибудь значение.
К примеру, сделаем искусственный набор
данных dna с пропущенным значением.
Это будет наш набор Investment,
и мы искусственно туда внесём
парочку пропущенных значений,
скажем, [1,2] будет
пропущенное значение и, скажем,
пятая строчка третий столбец
тоже будет пропущенное значение.
И можно посмотреть на наш набор данных
dna, и вот действительно видно,
что здесь искусственно
появилось пропущенное значение.
Два простых метода заполнения пропусков.
Первый — это линейная аппроксимация,
то есть компьютер возьмёт два
значения по краям и посчитает
среднее арифметическое между ними.
И второй простейший способ заполнения
пропусков — это будет скопировано
предыдущее значение, то есть что означает,
что показатель не менялся во времени.
То есть две идеи реализованы
автоматически — постоянные
скорость роста и заполнения
предыдущим значением.
Соответственно, одно
из них na.approx(dna).
Соответственно, это реализует
идею линейной интерполяции.
Ну первое наблюдение, к сожалению, пакет
не заполняет, потому что нет предыдущих.
И вторая идея заполнения
пропущенных значений,
na.locf(dna).
locf расшифровывается как last
observation carried forward,
то есть «перенос вперёд
последнего доступного значения».
И, соответственно,
это тоже способ заполнить пропуски.
Вот здесь два раза
подряд оказывается 0.76.

