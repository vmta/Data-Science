Теперь перейдем к анализу
какого-нибудь набора данных.
Мы вернемся ко встроенному
набору данных по инвестициям,
d <- Investment.
Превратим его в неупорядоченный
временной ряд: as.zoo(Investment).
Можно посмотреть на те же самые графики,
au_toplot(d),
скажем, построим графики первого,
второго столбика: au_toplot(d[,1:2]),
это у нас будет инвестиции и GNP.
Давайте нанесем их на один график,
так они будут занимать меньше
места и будут лучше видны.
А теперь попробуем оценить модель
с помощью метода наименьших квадратов,
и посмотреть, есть ли автокорреляция,
и побороться с ней, поскольку логично
ее ожидать, ведь у нас временной ряд,
и логично, что сегодняшний
показатель зависит от вчерашнего.
Посмотрим, от чего зависят
реальные инвестиции.
Значит, оценим модель,
равняется линейная модель.
Данные возьмем из набора
данных d и посмотрим,
от чего зависит переменная
реальной инвестиции.
И в качестве объясняющих возьмем
реальную процентную ставку и,
соответственно, реальный GNP.
Оценили модель, как всегда, смотрим,
что у нас там получилось: summary(model).
Можем посмотреть
на проверку гипотез о
равенстве коэффициентов нулю
и можем посмотреть
доверительные интервалы,
confint(model).
Соответственно, мы видим, что увеличение
реального GNP на 1 приводит к
увеличению инвестиций на 0.16,
увеличение процентной ставки негативно
сказывается на объеме инвестиций.
Попробуем определить теперь,
есть ли в нашей модели автокорреляция.
Для этого сначала посмотрим на графики
остатков, как текущее значение остатка
модели зависит от прошлого
значения остатков модели.
Для этого сначала дополним наш
исходный массив данных d с помощью
оцененных показателей,
то есть с помощью остатков,
с помощью прогнозных значений,
ну, а потом построим график.
Значит, d_aug = augment(model),
мы пополняем с помощью нашей
модели и пополняем с помощью
нее наш набор данных d.
Тут есть небольшой нюанс: набор
данных d является временным рядом,
а не табличкой с данными, с точки зрения
R, поэтому нам его надо сначала превратить
в табличку с данными, as.data.frame(d).
Давайте посмотрим,
что из себя представляет наша новая,
пополненная табличка с данными.
И мы видим, что помимо исходных
показателей GNP, Investment, Price,
Interest, RealGNP, RealInv,
RealInt, есть еще показатели,
которые добавились после оценки моделей,
а именно остатки, прогнозные значения,
ну, и там стандартизированные
остатки и другие показатели.
Нас интересуют в данном случае остатки:
как сегодняшний остаток зависит от
вчерашнего и зависит ли вообще.
Для начала мы построим график.
Возьмем данные из вот этого
расширенного набора данных d.
По горизонтали отложим предыдущий остаток,
то есть lag (.resid),
а по вертикали отложим текущее
значение остатка, .resid.
Наблюдений у нас, конечно, немного.
Давайте увеличим картинку,
чтобы она влезла в экран.
Но, тем не менее, несмотря на
небольшое количество наблюдений,
можно говорить все-таки о
положительной небольшой корреляции.
Посмотрите, действительно, если прошлое
значение остатка было больше 0,
то есть если предыдущий
остаток был больше 0,
то и последующий остаток… большинство из
них находится в правой верхней четверти.
Это означает, что если предыдущий
остаток был положительным, то,
скорее всего,
и следующий будет положительным.
И, наоборот, если вот предыдущий
остаток был отрицательным, меньше 0,
то это говорит, скорее,
о меньших значениях сегодняшнего остатка,
а это является признаком автокорреляции.
Как мы знаем из лекции, при автокорреляции
использование проверки гипотез,
которую статистический пакет выполняет
по умолчанию, не является корректным.
Нам нужно откорректировать стандартные
ошибки, чтобы правильно состоятельно
проверять гипотезы и правильно
строить доверительные интервалы.
Посмотрим на ковариационную матрицу
оценок коэффициентов, vcov(model).
Эта матрица рассчитана тем способом,
который не является состоятельным
в условиях автокорреляции,
то есть вот это вот 620 является плохой
оценкой для дисперсии свободного члена,
а вот эта, 5,61 – это, опять же,
несостоятельная оценка для дисперсии
β с крышкой при реальных инвестициях.
Мы можем легко подправить эту матрицу,
то есть использовать
алгоритм расчета,
устойчивый к автокорреляции,
vcovHAC (model), и получить другие оценки.
И мы видим, что оценки, робастные к
автокорреляции, существенно выше.
Здесь оценка дисперсии, например,
коэффициента при реальной процентной
ставке – 5,6, здесь та же самая
дисперсия практически в три раза больше.
Это говорит о том, что способ построения
доверительных интервалов по умолчанию
занижает их ширину, и правильные
доверительные интервалы будут шире.
Давайте попробуем сделать корректную
проверку гипотез и, соответственно,
построить правильные
доверительные интервалы.
Используем функцию coeftest
на отсутствие воздействия
объясняющих переменных на зависимую,
то есть coeftest(model),
и, соответственно, указываем,
что ковариационная матрица должна
использоваться правильная,
vcoHAC(model).
Можно сравнить результаты
исходного теста и теста
с использованием робастной
автокорреляции ковариационной матрицы.
Ну, мы видим, что, к счастью,
качественно результаты о значимости
коэффициентов не поменялись.
Первые два, как были незначимы,
так и остались незначимы.
Третий коэффициент, как был значим,
так и остался значим.
Теперь построим корректные
доверительные интервалы.
Для начала результаты расчета стандартных
ошибок поместим в отдельную табличку,
назовем ее conftable.
Для построения доверительных интервалов из
этой таблички нам потребуется только два,
собственно, показателя: самооценка и ее
корректно рассчитанная стандартная ошибка.
Соответственно, в табличку ci мы поместим
только их, 
data.frame(estimate=conftable[,1],se_ac= conftable[,2].
data.frame(estimate=conftable[,1],se_ac= conftable[,2].
data.frame(estimate=conftable[,1],se_ac= conftable[,2].
Значит, создали ci,
посмотрим на табличку ci.
В ней в настоящий момент есть
оценки и стандартные ошибки,
устойчивые к автокорреляции.
Соответственно, нам надо добавить
mu_tate мы изменяем наш набор данных ci,
и добавляем левые границы 95%-го 
интервала как оценки -1,
96 помножить на стандартные
ошибки и правую
границу доверительного
интервала добавляем как
оценку +1,96
помножить на стандартную ошибку,
устойчивую к автокорреляции.
Когда мы это сделали, можем посмотреть
на посчитанные доверительные
интервалы для оценок коэффициентов
и сравнить их с исходными, которые
посчитаны с использованием формулы по
умолчанию, не учитывающей автокорреляцию.
Если я посмотрю confint(model) и
правильный доверительный интервал,
то мы видим,
что в нашем примере доверительный интервал
для коэффициента при эффекте от
реального GNP практически не поменялся,
был от 0.12 до 0.21,
стал от 0.12 до 0.21, а вот,
например, доверительный интервал
для коэффициента измеряющего
эффекта изменения процентной ставки,
раньше мы были уверены,
что коэффициент лежит от -6 до 4
с уровнем доверия 95-%, то сейчас
уже доверительный интервал шире, то есть
наша оценка оказывается в реальности менее
точной из-за автокорреляции,
и эффект составляет от -8.5 до 6.5.

