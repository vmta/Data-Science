Мы говорили о том,
что коэффициенты бывают значимыми,
но несущественными,
и существенными, но не значимыми.
Один из способов почувствовать
существенный коэффициент или нет,
— это посчитать стандартизированные
коэффициенты β с крышкой,
то есть привести все объясняющие
переменные и объясняемую переменную
к неким универсальным единицам измерения,
чтобы они были сравнимы, а именно: вычесть
из каждой переменной её среднее и поделить
на оценённое стандартное отклонение.
Соответственно, мы это сделаем, построим
регрессию в стандартизированных переменных
и получим стандартизированные коэффициенты
β с крышкой, которые можно уже, например,
корректно сравнивать между собой,
и тем самым оценить силу влияния
переменной, не говоря про значимость.
Стандартизированные коэффициенты.
На шаге один мы преобразуем
каждую переменную,
масштабируем каждую переменную.
Значит, создадим набор h_st,
где мы изменим каждую переменную,
функция называется mutate_each, в наборе
данных h, а формула, по которой мы будем,
функция, по которой мы будем менять
каждую переменную, называется scale,
она осуществляет как раз
масштабирование, вычитание среднего и
деления на стандартную ошибку.
Стандартизировали переменные.
Можем также посмотреть на этот набор
стандартизированных переменных.
И теперь мы оцениваем ту же самую модель,
то есть я просто скопирую эту строчку
кода, за тем исключением, что нам надо её,
конечно, по-другому назвать.
Пусть будет model_st.
И, конечно, данные надо брать
не из исходного набора данных,
а там, где они уже стандартизированы,
то есть из набора данных h_st.
Запускаем.
Смотрим отчёт по
стандартизированной модели.
И здесь уже вот эти коэффициенты,
их можно сравнивать между собой,
они уже показывают более,
в каком-то смысле,
объективно силу влияния каждой переменной.
Можно также визуализировать зависимость.
Вот была визуализирована зависимость
коэффициентов исходных не
стандартизированных.
Точно так же с помощью
функции sjp.lm можно
визуализировать коэффициенты
в стандартизированных,
в стандартизированных переменных.
Для этого на самом деле даже не
нужны все эти преобразования,
функция sjp.lm всё это сделает сама.
Можно просто указать исходную
модель model и указать,
что нам нужны
стандартизованные коэффициенты.
Это опция showStandardBeta = TRUE.
И, соответственно, сейчас на
графике появятся на этот раз
стандартизированные коэффициенты.
Здесь уже доверительные
интервалы не строятся,
потому что они в других единицах
измерения по сравнению с исходными.
Сейчас мы на искусственных данных
проиллюстрируем идею того,
что нельзя просто так построить
регрессию и отвечать на вопрос,
а какие коэффициенты у меня значимы.
Надо сначала сформулировать гипотезу
и проверять те коэффициенты,
которые вас интересуют.
Давайте попробуем.
Искусственный эксперимент.
Мы сочиним в нашем искусственном
эксперименте совершенно несвязанный игрек,
который никак не зависит от
якобы объясняющих переменных.
У нас будет 40 якобы
объясняющих переменных,
одна якобы зависимая,
хотя на самом деле независимая,
и мы будем строить,
оценивать модель линейной регрессии.
Давайте сначала сгенерим наши данные.
Сначала сгенерим матрицу.
Наша матрица D, это будет матрица,
мы расположим в этой матрице,
соответственно, пусть в
матрице будет 100 строк.
Количество строк равно ста.
И в этой матрице мы, соответственно,
расположим нормальные случайные величины,
случайно сгенерированные,
в количестве 100 умножить на 41,
потому что у нас будет 40 регрессоров,
одна объясняемая переменная.
Давайте укажем, что среднее равно там
будет 0, и стандартная ошибка равна 1.
Соответственно, сгенерировали
матрицу иксов.
Превратим её в набор данных.
df — это будет data.frame (D).
И теперь оценим новую модель.
Как бы мы знаем,
что на самом деле зависимости нет,
поэтому давайте так и
напишем: model_pusto.
Это линейная модель,
данные мы берём из таблички данных df.
А что у нас является регрессорами?
Давайте посмотрим, какие названия
присвоил R по умолчанию нашим переменным,
которые мы сгенерили.
Смотрим на набор данных df и видим,что
здесь 41 переменная: x1,
сгенерированная случайно, x2,
сгенерированная случайно, и так далее,
x41, сгенерированная случайно.
По каждой будет 100 значений,
но показаны только первые несколько.
И мы, соответственно, построим
регрессию переменной x1 на остальные.
Когда переменных много,
то перечислять их все, конечно, лень,
и в R для ленивых сделано
специальное сокращение «точка»,
которое означает, что, пытаюсь объяснить
переменную x1 всеми остальными,
имеющимися в моём наборе данных.
Оцениваем эту модель-«пустышку».
И смотрим на значимость
коэффициентов: обнаружит ли компьютер,
что якобы какие-то коэффициенты
являются значимыми.
И здесь мы видим следующий факт,
что вот видно,
тут компьютер поставил автоматом
точечку рядом с теми коэффициентами,
которые значимы на десятипроцентном
уровне значимости.
Соответственно, на десятипроцентном уровне
значимости у меня будет отвергаться
гипотеза о том, что x17 не влияет,
будет отвергаться гипотеза о том,
что x6 не влияет, и будет отвергаться
гипотеза о том, что x21 не влияет,
то есть эти три переменные, выходит,
влияют на зависимую переменную x1,
хотя на самом деле всё
генерировалось случайно.
С чем это связано?
Это связано с тем,
что когда мы фиксируем уровень значимости,
мы соглашаемся на некоторую
вероятность ошибиться.
Соответственно, когда мы зафиксировали
уровень значимости 10%, это означает,
что с вероятностью 10%
мы в случае на самом деле
отсутствия зависимости якобы её обнаружим.
Соответственно, с десятипроцентным
шансом мы в данной ситуации
каждый коэффициент признаём значимым.
Ну вот у меня компьютер обнаружил
три ложно значимых коэффициента.
Но на самом деле,
поскольку данные генерировались случайно,
у вас их может быть чуть больше или
чуть меньше, тут уж как повезёт,
но хотя бы один будет практически
наверняка, потому что 40 экспериментов,
и в каждом эксперименте —
десятипроцентный шанс сделать ошибку.
Соответственно, из этого искусственного
эксперимента нужно сделать простой вывод,
что стратегия «я оценю
модель с большим количеством
объясняющих переменных и
выпишу из них значимые,
и скажу, что от них игрек зависит»,
— неправильная,
потому что в силу того, что есть для
каждого регрессора десятипроцентный
или пятипроцентный шанс сделать ошибку,
при большом количестве регрессоров
кто-то якобы значимым будет, даже если
на самом деле никакой зависимости нет.
И ещё один маленький полезный сюжет.
Иногда возникает необходимость
сравнить рядом несколько моделей.
Сравнить несколько моделей.
К примеру, я оценил очень похожую
на исходную самую первую модель,
оценю очень похожую модель,
но куда не включу Examination.
Вот не включил сюда Examination.
Ой, надо было её model2 назвать.
Давайте, значит,
ещё раз запустим первую строчку.
А эту модель более простую назовём model2.
И теперь хочу сравнить
несколько моделей рядом.
Можно, конечно, смотреть на первый
результат оценивания, на второй,
но так иногда неудобно.
Поэтому мы давайте сделаем табличку,
в которой сравниваются сразу
несколько моделей compar_12.
Функция mtable нам поможет из пакета memisc.
И тут мы напишем,
что мы сравниваем model и model2.
Всё, сравнили, теперь можно
посмотреть на результаты сравнения.
И у нас просто рядом будут
написаны две модели.
Для каждой — все оценки коэффициентов
друг напротив друга и в
скобках стандартные ошибки.
Также указана значимость в виде звёздочек.
Соответственно, мы можем сразу
одним взглядом видеть две модели.
И также для сравнения приведены
R-квадраты в каждой модели.
Вот видно, например, что при выкидывании
переменной Examination R-квадрат
резко падает, практически в два раза.
Также у нас есть
оценка σ с крышкой,
да, 9.6 в первой модели, 11 — во второй.
И количество наблюдений 47.
Остальные показатели мы пока ещё не знаем,
но скоро с ними познакомимся.

