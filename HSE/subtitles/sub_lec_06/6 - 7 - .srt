1
00:00:13,270 --> 00:00:18,908
Рассмотрим встроенный набор данных,

2
00:00:18,908 --> 00:00:22,230
многомерный временной ряд
под названием Investment,

3
00:00:22,230 --> 00:00:26,710
data("Investment").

4
00:00:26,710 --> 00:00:31,410
Давайте посмотрим описание этого ряда,

5
00:00:31,410 --> 00:00:35,320
help("Investment").

6
00:00:35,320 --> 00:00:43,191
Соответственно, это набор данных с
1963-го по 1982-й год, семь переменных.

7
00:00:43,191 --> 00:00:44,706
Это данные по Америке.

8
00:00:44,706 --> 00:00:49,168
Соответственно, GNP,
валовый национальный продукт,

9
00:00:49,168 --> 00:00:52,630
инвестиции, индекс цен,
процентная ставка и,

10
00:00:52,630 --> 00:00:56,490
соответственно, реальный валовый
национальный продукт и так далее.

11
00:00:56,490 --> 00:01:02,093
Соответственно, как можно работать с этим
объектом, самые простейшие операции?

12
00:01:02,093 --> 00:01:09,060
Во-первых, можно посмотреть, когда
начинаются данные, start(Invesnment).

13
00:01:09,060 --> 00:01:13,640
1963-й.

14
00:01:13,640 --> 00:01:20,196
Можно посмотреть end(Investment),
когда заканчивается наш временной ряд.

15
00:01:20,196 --> 00:01:22,590
Соответственно, 82-й год.

16
00:01:22,590 --> 00:01:25,558
Можно посмотреть, собственно, индекс,

17
00:01:25,558 --> 00:01:30,060
переменную, которая отвечает за время,
time(Investment).

18
00:01:30,060 --> 00:01:33,923
И видно,
что это вот годовые временные ряды,

19
00:01:33,923 --> 00:01:40,050
частота — одно наблюдение на один год:
начало, конец и, собственно, сами индексы.

20
00:01:40,050 --> 00:01:45,561
И есть такое понятие как coredata,
то есть это основная часть массива,

21
00:01:45,561 --> 00:01:48,671
то есть без переменной,
которая отвечает за время,

22
00:01:48,671 --> 00:01:54,770
а просто сами значения показателей,
coredata(Investment).

23
00:01:54,770 --> 00:01:59,768
И здесь у нас есть GNP, Investment,

24
00:01:59,768 --> 00:02:02,423
Price и так далее.

25
00:02:02,423 --> 00:02:10,570
Соответственно, какие ещё простые
операции позволяет делать пакет zoo?

26
00:02:10,570 --> 00:02:15,070
Например, можно восстановить
некоторые пропущенные значения одним

27
00:02:15,070 --> 00:02:17,170
из двух простейших алгоритмов.

28
00:02:17,170 --> 00:02:21,777
Давайте искусственно введём
пропущенные значения.

29
00:02:21,777 --> 00:02:22,992
Скажем, GNP.

30
00:02:22,992 --> 00:02:26,630
Поставим туда пропуск на
какое-нибудь значение.

31
00:02:26,630 --> 00:02:34,360
К примеру, сделаем искусственный набор
данных dna с пропущенным значением.

32
00:02:34,360 --> 00:02:37,390
Это будет наш набор Investment,

33
00:02:37,390 --> 00:02:41,960
и мы искусственно туда внесём
парочку пропущенных значений,

34
00:02:41,960 --> 00:02:47,300
скажем, [1,2] будет
пропущенное значение и, скажем,

35
00:02:47,300 --> 00:02:52,220
пятая строчка третий столбец

36
00:02:52,220 --> 00:02:56,635
тоже будет пропущенное значение.

37
00:02:56,635 --> 00:03:01,050
И можно посмотреть на наш набор данных
dna, и вот действительно видно,

38
00:03:01,050 --> 00:03:06,180
что здесь искусственно
появилось пропущенное значение.

39
00:03:06,180 --> 00:03:09,157
Два простых метода заполнения пропусков.

40
00:03:09,157 --> 00:03:13,970
Первый — это линейная аппроксимация,
то есть компьютер возьмёт два

41
00:03:13,970 --> 00:03:18,058
значения по краям и посчитает
среднее арифметическое между ними.

42
00:03:18,058 --> 00:03:22,019
И второй простейший способ заполнения
пропусков — это будет скопировано

43
00:03:22,019 --> 00:03:26,568
предыдущее значение, то есть что означает,
что показатель не менялся во времени.

44
00:03:26,568 --> 00:03:31,577
То есть две идеи реализованы
автоматически — постоянные

45
00:03:31,577 --> 00:03:36,142
скорость роста и заполнения
предыдущим значением.

46
00:03:36,142 --> 00:03:43,330
Соответственно, одно
из них na.approx(dna).

47
00:03:43,330 --> 00:03:50,933
Соответственно, это реализует
идею линейной интерполяции.

48
00:03:50,933 --> 00:03:56,231
Ну первое наблюдение, к сожалению, пакет
не заполняет, потому что нет предыдущих.

49
00:03:56,231 --> 00:03:59,290
И вторая идея заполнения
пропущенных значений,

50
00:03:59,290 --> 00:04:06,600
na.locf(dna).

51
00:04:06,600 --> 00:04:10,286
locf расшифровывается как last
observation carried forward,

52
00:04:10,286 --> 00:04:13,910
то есть «перенос вперёд
последнего доступного значения».

53
00:04:13,910 --> 00:04:17,801
И, соответственно,
это тоже способ заполнить пропуски.

54
00:04:17,801 --> 00:04:26,050
Вот здесь два раза
подряд оказывается 0.76.

