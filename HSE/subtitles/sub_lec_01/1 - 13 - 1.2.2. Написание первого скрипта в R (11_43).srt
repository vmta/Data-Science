1
00:00:13,250 --> 00:00:15,634
В консольном режиме,

2
00:00:15,634 --> 00:00:20,766
в котором мы работали только что,
команда исполняется немедленно.

3
00:00:20,766 --> 00:00:22,802
Ввел команду, нажал Enter,
она исполнилась.

4
00:00:22,802 --> 00:00:25,300
Ввел следующую команду,
нажал Enter, она исполнилась.

5
00:00:25,300 --> 00:00:29,767
В реальной работе, конечно, реальный
анализ данных связан с выполнением

6
00:00:29,767 --> 00:00:35,191
большого количества команд, и поэтому
имеет смысл набрать их все в одном файле,

7
00:00:35,191 --> 00:00:37,720
а потом все одним разом запустить.

8
00:00:37,720 --> 00:00:40,649
И этот второй режим работы
– это написание скрипта.

9
00:00:40,649 --> 00:00:43,260
Перейдем к написанию
нашего первого скрипта.

10
00:00:43,260 --> 00:00:47,408
Выбираем, нажимаем плюсик
и тут выбираем R Script,

11
00:00:47,408 --> 00:00:52,307
соответственно вот у нас появится
дополнительное окошко, и в этом окошке,

12
00:00:52,307 --> 00:00:55,370
когда мы нажимаем Enter,
то ничего не происходит.

13
00:00:55,370 --> 00:00:57,725
Команда сразу выполняться не будет.

14
00:00:57,725 --> 00:01:00,600
Давайте создадим здесь несколько векторов.

15
00:01:00,600 --> 00:01:06,814
Например, создадим вектор х из чисел 23,

16
00:01:06,814 --> 00:01:10,670
15, 46, NA.

17
00:01:10,670 --> 00:01:15,264
Вектор z из чисел 5,

18
00:01:15,264 --> 00:01:18,338
6, NA, 8.

19
00:01:18,338 --> 00:01:26,370
И давайте попробуем исполнить
эти введенные команды,

20
00:01:26,370 --> 00:01:30,704
то есть здесь команда не
выполняется сразу после написания.

21
00:01:30,704 --> 00:01:35,335
Чтобы исполнить команду достаточно встать
в любое место строки, можно в конец,

22
00:01:35,335 --> 00:01:37,084
можно в начало, не обязательно.

23
00:01:37,084 --> 00:01:39,090
Где находится курсор, там и отлично.

24
00:01:39,090 --> 00:01:43,196
И нажать в зависимости
от операционной системы,

25
00:01:43,196 --> 00:01:50,690
под Windows это будет Ctrl+Enter,
а на Маке это будет Command+Enter.

26
00:01:50,690 --> 00:01:56,530
Соответственно, исполнилась
первая команда,

27
00:01:56,530 --> 00:02:01,672
х = вектору 23, 15,

28
00:02:01,672 --> 00:02:06,730
46, пропущенное значение,
и исполняем вторую команду z = 5,

29
00:02:06,730 --> 00:02:10,500
6, пропущенное значение, 8.

30
00:02:10,500 --> 00:02:13,024
Что я могу сделать с векторами?

31
00:02:13,024 --> 00:02:19,086
У векторов я могу попробовать посчитать,
например, среднее значение.

32
00:02:19,086 --> 00:02:22,970
Если я наберу mean(x) и нажму Ctrl+Enter,

33
00:02:22,970 --> 00:02:27,580
то компьютер попытается посчитать
собственное значение, среднее значение.

34
00:02:27,580 --> 00:02:30,158
Но поскольку есть пропущенное наблюдение,

35
00:02:30,158 --> 00:02:33,830
то узнать среднее значение вот
этих четырех чисел невозможно.

36
00:02:33,830 --> 00:02:37,730
Ну, в R есть удобная работа
с пропущенными наблюдениями,

37
00:02:37,730 --> 00:02:44,410
в данном случаем мне достаточно
просто указать, что опцию,

38
00:02:44,410 --> 00:02:48,578
опцию «опустить пропущенные значения»,

39
00:02:48,578 --> 00:02:53,585
то есть я набираю среднее значение
х и указываю дополнительные опции,

40
00:02:53,585 --> 00:02:57,930
что пропущенные значения
na надо rm опустить.

41
00:02:57,930 --> 00:03:01,197
И получается, что среднее значение,

42
00:03:01,197 --> 00:03:06,702
если не считать пропущенные
неизвестные значения, равно 28.

43
00:03:06,702 --> 00:03:13,380
Еще раз не забывайте, что работает Tab,
то есть я на самом деле не набирал na.rm.

44
00:03:13,380 --> 00:03:17,208
Я набрал, например, mean(z,),

45
00:03:17,208 --> 00:03:22,720
а дальше нажал Tab и посмотрел, какие
опции есть у функции, их можно прочитать.

46
00:03:22,720 --> 00:03:27,620
Соответственно, вот выбрал опцию na.rm,
нажал Enter,

47
00:03:27,620 --> 00:03:29,935
установил, что ее надо использовать,-

48
00:03:29,935 --> 00:03:35,072
TRUE (истинное значение),
и получил среднее значение переменной

49
00:03:35,072 --> 00:03:39,576
z при игнорировании пропущенных значений.

50
00:03:39,576 --> 00:03:42,030
Помимо, естественно, среднего,

51
00:03:42,030 --> 00:03:45,029
можно посчитать над векторами
кучу других операций.

52
00:03:45,029 --> 00:03:47,060
Например, можно посчитать сумму.

53
00:03:47,060 --> 00:03:51,470
Опять же если не игнорировать
пропущенные значения, сумма не известна,

54
00:03:51,470 --> 00:03:55,339
однако можно проигнорировать
пропущенные значения

55
00:03:55,339 --> 00:03:59,980
и получить сумму всех чисел,
кроме пропущенных.

56
00:03:59,980 --> 00:04:01,257
Следующий объект,

57
00:04:01,257 --> 00:04:06,220
который очень часто встречается в R
помимо вектора – это табличка с данными.

58
00:04:06,220 --> 00:04:10,709
Табличка с данными – это двумерный объект,
то есть есть несколько столбцов

59
00:04:10,709 --> 00:04:15,340
одинаковой длины и много-много строк,
как правило.

60
00:04:15,340 --> 00:04:19,259
Давайте объединим наши
вектора x и z в табличку d.

61
00:04:19,259 --> 00:04:24,357
Ну пусть, к примеру,
х – это будет рост некоторых инопланетян,

62
00:04:24,357 --> 00:04:28,310
а z – это будет вес некоторых
четырех инопланетян.

63
00:04:28,310 --> 00:04:32,160
Создадим табличку d data.frame.

64
00:04:32,160 --> 00:04:36,196
Давайте напишем,

65
00:04:36,196 --> 00:04:41,750
что рост мы берем из переменной х,
а вес берем из переменной z.

66
00:04:41,750 --> 00:04:44,784
Нажимаем Ctrl+Enter,

67
00:04:44,784 --> 00:04:50,294
и компьютер объединил два
вектора х и z в табличку d.

68
00:04:50,294 --> 00:04:53,246
Давайте посмотрим,
как устроена табличка d.

69
00:04:53,246 --> 00:04:55,400
Напишем d, нажмем Ctrl+Enter.

70
00:04:55,400 --> 00:04:57,860
И вот мы видим,
что d – это двумерная табличка,

71
00:04:57,860 --> 00:05:00,200
здесь есть переменная
рост и переменная вес.

72
00:05:00,200 --> 00:05:00,980
И наблюдение.

73
00:05:00,980 --> 00:05:02,060
Первое наблюдение-

74
00:05:02,060 --> 00:05:03,090
рост 23, вес 5.

75
00:05:03,090 --> 00:05:04,512
Второе наблюдение-

76
00:05:04,512 --> 00:05:06,570
рост 15, вес 6 и так далее.

77
00:05:06,570 --> 00:05:10,100
Как адресовать двумерный объект?

78
00:05:10,100 --> 00:05:14,110
Соответственно, можно адресовать
любой конкретный элемент.

79
00:05:14,110 --> 00:05:19,670
Например, если я хочу раздобыть
элемент из 4-й строки 1-го столбца,

80
00:05:19,670 --> 00:05:25,510
то мне надо написать d [4, 1].

81
00:05:25,510 --> 00:05:28,302
Это будет 4-я строка, 1-й столбец.

82
00:05:28,302 --> 00:05:33,397
И я нажимаю Ctrl+Enter,
и действительно это пропущенное значение.

83
00:05:33,397 --> 00:05:40,980
Например, могу раздобыть элемент из
3-й строки 1-го столбца: d [3, 1]-

84
00:05:40,980 --> 00:05:44,950
это 46.

85
00:05:44,950 --> 00:05:47,535
Могу раздобыть какую-нибудь
строчку целиком,

86
00:05:47,535 --> 00:05:52,069
для этого тогда надо просто пропустить
номер столбца, не указывать его: d [2,

87
00:05:52,069 --> 00:05:58,170
] и, не указав номер столбца,
я получаю всю соответствующую строчку.

88
00:05:58,170 --> 00:06:01,574
Аналогично, не указав номер строки,

89
00:06:01,574 --> 00:06:07,670
можно получить весь столбец целиком d [,
2] – это будет второй столбец.

90
00:06:07,670 --> 00:06:16,600
Также можно адресовать столбцы по именам.

91
00:06:16,600 --> 00:06:25,118
Например, если я напишу d$rost,
опять же не забывайте, что работает Tab.

92
00:06:25,118 --> 00:06:29,204
Я начал писать d$ro и нажимаю Tab,
хоп, и само появляется st.

93
00:06:29,204 --> 00:06:34,092
Это, соответственно,
будет столбец rost из таблички d,

94
00:06:34,092 --> 00:06:40,900
и могу точно так же после $ нажать Tab
и посмотреть, какие есть варианты.

95
00:06:40,900 --> 00:06:44,490
d$ves из таблички d.

96
00:06:44,490 --> 00:06:50,890
Помимо табличек с данными, в R также
очень популярен такой объект, как списки.

97
00:06:50,890 --> 00:06:54,640
Список удобно себе представлять
как чулан со всяким хламом.

98
00:06:54,640 --> 00:06:59,540
Если табличка обладает
стандартными размерами,

99
00:06:59,540 --> 00:07:04,354
ну обязательно в каждой табличке
есть какое-то число строк,

100
00:07:04,354 --> 00:07:09,560
какое-то число столбцов, и в каждом
столбце одинаковое количество строк,

101
00:07:09,560 --> 00:07:14,380
то в список могут входить
объекты совершенно разнородные.

102
00:07:14,380 --> 00:07:18,790
Ну давайте попробуем создать, например,
список, который называется my_list,

103
00:07:18,790 --> 00:07:24,660
в который войдут число а = 7,

104
00:07:24,660 --> 00:07:29,740
вектор b чисел от 10 до 20 и табличка,

105
00:07:29,740 --> 00:07:34,540
табличка, под названием table,

106
00:07:34,540 --> 00:07:40,740
и мы под названием table в список my_list
поместим нашу уже созданную табличку d.

107
00:07:40,740 --> 00:07:44,960
Нажимаем Ctrl+Enter,
у нас создался объект my_list.

108
00:07:44,960 --> 00:07:49,910
my_list – это набор из трех
совершенно разнородных объектов.

109
00:07:49,910 --> 00:07:54,810
my_list$a – это число 7,

110
00:07:54,810 --> 00:08:00,320
my_list$b – это вектор,

111
00:08:00,320 --> 00:08:06,540
my_list$table, нажимаем
Ctrl+Enter – это целая табличка.

112
00:08:06,540 --> 00:08:11,940
Очень часто результаты оценивания всяких
моделей представлены в виде списка,

113
00:08:11,940 --> 00:08:16,224
потому что, как правило, когда мы будем
оценивать с помощью метода наименьших

114
00:08:16,224 --> 00:08:21,206
квадратов модель, то результатом
оценивания являются и вектор оценок β с

115
00:08:21,206 --> 00:08:26,315
крышкой, и число R-квадрат,
то поэтому результаты

116
00:08:26,315 --> 00:08:30,980
оценивания многих функций в
R являются именно списком.

117
00:08:30,980 --> 00:08:36,546
Список адресуется немножко по-другому,
чем таблица.

118
00:08:36,546 --> 00:08:42,021
Ну, во-первых,
работает один из старых способов адресации

119
00:08:42,021 --> 00:08:48,282
по имени входящего объекта,
то есть когда у нас в табличку входило,

120
00:08:48,282 --> 00:08:53,327
столбец рост, то мы могли написать

121
00:08:53,327 --> 00:09:01,410
d$rost (d$rost) и получить вектор,
состоящий из 4-х чисел.

122
00:09:01,410 --> 00:09:06,561
Такой же способ адресации работы в списке,
ну можно еще адресовать по номерам.

123
00:09:06,561 --> 00:09:08,920
Например, если я напишу my_list,

124
00:09:08,920 --> 00:09:14,320
и в двойных квадратных скобках
можно указать номер объекта,

125
00:09:14,320 --> 00:09:19,196
ну например, у меня тут 3 объекта: число,
вектор и табличка.

126
00:09:19,196 --> 00:09:24,783
Соответственно, если я в квадратных
скобках напишу my_list2,

127
00:09:24,783 --> 00:09:28,330
то это будет второй объект в списке.

128
00:09:28,330 --> 00:09:31,585
Второй объект в списке это будет вектор b.

129
00:09:31,585 --> 00:09:35,090
Можно по именам, а можно по номерам.

130
00:09:35,090 --> 00:09:40,106
Когда вы написали длинный-длинный скрипт

131
00:09:40,106 --> 00:09:45,710
с кучей нужных вам команд,
вы можете радостно написать,

132
00:09:45,710 --> 00:09:51,340
«ура!» и сохранить ваш скрипт
для дальнейшего использования.

133
00:09:51,340 --> 00:09:53,402
Выбираем File, Save.

134
00:09:53,402 --> 00:09:58,327
Когда вы работаете с русским языком,
один из первых нюансов,

135
00:09:58,327 --> 00:10:01,645
с которым вам придется столкнуться
– это разные кодировки.

136
00:10:01,645 --> 00:10:06,300
Русские буквы можно закодировать
в файле разными способами.

137
00:10:06,300 --> 00:10:11,689
Два самых распространенных способа
– это (самых популярных в России),

138
00:10:11,689 --> 00:10:16,810
это, соответственно, CP1251,
который распространен под Windows,

139
00:10:16,810 --> 00:10:21,252
и UTF-8, который используется
под Маком и на Линуксе.

140
00:10:21,252 --> 00:10:26,228
Соответственно, удобней оказывается UTF-8,

141
00:10:26,228 --> 00:10:34,097
потому что эта кодировка позволяет в одном
файле использовать не только русский язык,

142
00:10:34,097 --> 00:10:39,263
но, скажем, там немецкие умляуты,
французские акценты и так далее.

143
00:10:39,263 --> 00:10:42,562
Поэтому мы будем сохранять
в кодировке UTF-8 и,

144
00:10:42,562 --> 00:10:47,525
соответственно, здесь мы поставим галочку,

145
00:10:47,525 --> 00:10:52,860
что эта кодировка UTF-8 будет являться
кодировкой по умолчанию для всех файлов.

146
00:10:52,860 --> 00:10:58,504
Однако, если вы столкнетесь с каким-то

147
00:10:58,504 --> 00:11:03,663
явлением, увидите,
что у вас не русские буквы,

148
00:11:03,663 --> 00:11:08,634
а какие-то кракозябры, ну вот,
например, если я открою файл в

149
00:11:08,634 --> 00:11:13,390
неправильной кодировке,
сейчас мой файл записан в кодировке UTF-8.

150
00:11:13,390 --> 00:11:18,237
Однако если я выберу
неправильную кодировку,

151
00:11:18,237 --> 00:11:23,978
укажу компьютеру, что это кодировка
CP1251, то «ура» превратится в кракозябры.

152
00:11:23,978 --> 00:11:29,099
Поэтому если вы видите вместо комментариев
кракозябры, то вы выбираете File,

153
00:11:29,099 --> 00:11:33,870
Reopen with Encoding и выбираете,
скорей всего, одну из двух кодировок-

154
00:11:33,870 --> 00:11:37,600
либо CP1251, либо UTF-8.

